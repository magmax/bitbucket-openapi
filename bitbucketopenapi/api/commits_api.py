# coding: utf-8

"""
    Bitbucket API

    Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.  # noqa: E501

    The version of the OpenAPI document: 2.0
    Contact: support@bitbucket.org
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from bitbucketopenapi.api_client import ApiClient
from bitbucketopenapi.exceptions import (
    ApiTypeError,
    ApiValueError
)


class CommitsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_repositories_by_username_by_repo_slug_commit_by_node_approve(self, username, node, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_commit_by_node_approve  # noqa: E501

        Approve the specified commit as the authenticated user.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_commit_by_node_approve(username, node, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str node: The commit's SHA1. (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Participant
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_repositories_by_username_by_repo_slug_commit_by_node_approve_with_http_info(username, node, repo_slug, **kwargs)  # noqa: E501

    def create_repositories_by_username_by_repo_slug_commit_by_node_approve_with_http_info(self, username, node, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_commit_by_node_approve  # noqa: E501

        Approve the specified commit as the authenticated user.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_commit_by_node_approve_with_http_info(username, node, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str node: The commit's SHA1. (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Participant, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'node', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repositories_by_username_by_repo_slug_commit_by_node_approve" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `create_repositories_by_username_by_repo_slug_commit_by_node_approve`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in local_var_params or
                local_var_params['node'] is None):
            raise ApiValueError("Missing the required parameter `node` when calling `create_repositories_by_username_by_repo_slug_commit_by_node_approve`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `create_repositories_by_username_by_repo_slug_commit_by_node_approve`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'node' in local_var_params:
            path_params['node'] = local_var_params['node']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/commit/{node}/approve', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Participant',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repositories_by_username_by_repo_slug_commit_by_node_comments(self, node, username, repo_slug, body, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_commit_by_node_comments  # noqa: E501

        Creates new comment on the specified commit.  To post a reply to an existing comment, include the `parent.id` field:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\   -X POST -u evzijst \\   -H 'Content-Type: application/json' \\   -d '{\"content\": {\"raw\": \"One more thing!\"},        \"parent\": {\"id\": 5728901}}' ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_commit_by_node_comments(node, username, repo_slug, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str node: The commit's SHA1. (required)
        :param str username: This can either be the username or the UUID of the user, surrounded by curly-braces, for example: `{user UUID}`.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param CommitComment body: The specified comment. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_repositories_by_username_by_repo_slug_commit_by_node_comments_with_http_info(node, username, repo_slug, body, **kwargs)  # noqa: E501

    def create_repositories_by_username_by_repo_slug_commit_by_node_comments_with_http_info(self, node, username, repo_slug, body, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_commit_by_node_comments  # noqa: E501

        Creates new comment on the specified commit.  To post a reply to an existing comment, include the `parent.id` field:  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\   -X POST -u evzijst \\   -H 'Content-Type: application/json' \\   -d '{\"content\": {\"raw\": \"One more thing!\"},        \"parent\": {\"id\": 5728901}}' ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_commit_by_node_comments_with_http_info(node, username, repo_slug, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str node: The commit's SHA1. (required)
        :param str username: This can either be the username or the UUID of the user, surrounded by curly-braces, for example: `{user UUID}`.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param CommitComment body: The specified comment. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['node', 'username', 'repo_slug', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repositories_by_username_by_repo_slug_commit_by_node_comments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'node' is set
        if ('node' not in local_var_params or
                local_var_params['node'] is None):
            raise ApiValueError("Missing the required parameter `node` when calling `create_repositories_by_username_by_repo_slug_commit_by_node_comments`")  # noqa: E501
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `create_repositories_by_username_by_repo_slug_commit_by_node_comments`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `create_repositories_by_username_by_repo_slug_commit_by_node_comments`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `create_repositories_by_username_by_repo_slug_commit_by_node_comments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'node' in local_var_params:
            path_params['node'] = local_var_params['node']  # noqa: E501
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/commit/{node}/comments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repositories_by_username_by_repo_slug_commits(self, username, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_commits  # noqa: E501

        Identical to `GET /repositories/{username}/{repo_slug}/commits`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_commits(username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_repositories_by_username_by_repo_slug_commits_with_http_info(username, repo_slug, **kwargs)  # noqa: E501

    def create_repositories_by_username_by_repo_slug_commits_with_http_info(self, username, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_commits  # noqa: E501

        Identical to `GET /repositories/{username}/{repo_slug}/commits`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_commits_with_http_info(username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Error, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repositories_by_username_by_repo_slug_commits" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `create_repositories_by_username_by_repo_slug_commits`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `create_repositories_by_username_by_repo_slug_commits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/commits', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repositories_by_username_by_repo_slug_commits_by_revision(self, username, revision, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_commits_by_revision  # noqa: E501

        Identical to `GET /repositories/{username}/{repo_slug}/commits`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_commits_by_revision(username, revision, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str revision: (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_repositories_by_username_by_repo_slug_commits_by_revision_with_http_info(username, revision, repo_slug, **kwargs)  # noqa: E501

    def create_repositories_by_username_by_repo_slug_commits_by_revision_with_http_info(self, username, revision, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_commits_by_revision  # noqa: E501

        Identical to `GET /repositories/{username}/{repo_slug}/commits`, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_commits_by_revision_with_http_info(username, revision, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str revision: (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Error, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'revision', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repositories_by_username_by_repo_slug_commits_by_revision" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `create_repositories_by_username_by_repo_slug_commits_by_revision`")  # noqa: E501
        # verify the required parameter 'revision' is set
        if ('revision' not in local_var_params or
                local_var_params['revision'] is None):
            raise ApiValueError("Missing the required parameter `revision` when calling `create_repositories_by_username_by_repo_slug_commits_by_revision`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `create_repositories_by_username_by_repo_slug_commits_by_revision`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'revision' in local_var_params:
            path_params['revision'] = local_var_params['revision']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/commits/{revision}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_repositories_by_username_by_repo_slug_commit_by_node_approve(self, username, node, repo_slug, **kwargs):  # noqa: E501
        """delete_repositories_by_username_by_repo_slug_commit_by_node_approve  # noqa: E501

        Redact the authenticated user's approval of the specified commit.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repositories_by_username_by_repo_slug_commit_by_node_approve(username, node, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str node: The commit's SHA1. (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_repositories_by_username_by_repo_slug_commit_by_node_approve_with_http_info(username, node, repo_slug, **kwargs)  # noqa: E501

    def delete_repositories_by_username_by_repo_slug_commit_by_node_approve_with_http_info(self, username, node, repo_slug, **kwargs):  # noqa: E501
        """delete_repositories_by_username_by_repo_slug_commit_by_node_approve  # noqa: E501

        Redact the authenticated user's approval of the specified commit.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repositories_by_username_by_repo_slug_commit_by_node_approve_with_http_info(username, node, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str node: The commit's SHA1. (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'node', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_repositories_by_username_by_repo_slug_commit_by_node_approve" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `delete_repositories_by_username_by_repo_slug_commit_by_node_approve`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in local_var_params or
                local_var_params['node'] is None):
            raise ApiValueError("Missing the required parameter `node` when calling `delete_repositories_by_username_by_repo_slug_commit_by_node_approve`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `delete_repositories_by_username_by_repo_slug_commit_by_node_approve`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'node' in local_var_params:
            path_params['node'] = local_var_params['node']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/commit/{node}/approve', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_commit_by_node(self, username, node, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_commit_by_node  # noqa: E501

        Returns the specified commit.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_commit_by_node(username, node, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str node: The commit's SHA1. (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Commit
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_commit_by_node_with_http_info(username, node, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_commit_by_node_with_http_info(self, username, node, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_commit_by_node  # noqa: E501

        Returns the specified commit.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_commit_by_node_with_http_info(username, node, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str node: The commit's SHA1. (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Commit, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'node', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_commit_by_node" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_commit_by_node`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in local_var_params or
                local_var_params['node'] is None):
            raise ApiValueError("Missing the required parameter `node` when calling `get_repositories_by_username_by_repo_slug_commit_by_node`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_commit_by_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'node' in local_var_params:
            path_params['node'] = local_var_params['node']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/commit/{node}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Commit',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_commit_by_node_comments(self, username, node, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_commit_by_node_comments  # noqa: E501

        Returns the commit's comments.  This includes both global and inline comments.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_commit_by_node_comments(username, node, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str node: The commit's SHA1. (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedCommitComments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_commit_by_node_comments_with_http_info(username, node, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_commit_by_node_comments_with_http_info(self, username, node, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_commit_by_node_comments  # noqa: E501

        Returns the commit's comments.  This includes both global and inline comments.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_commit_by_node_comments_with_http_info(username, node, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str node: The commit's SHA1. (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedCommitComments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'node', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_commit_by_node_comments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_commit_by_node_comments`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in local_var_params or
                local_var_params['node'] is None):
            raise ApiValueError("Missing the required parameter `node` when calling `get_repositories_by_username_by_repo_slug_commit_by_node_comments`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_commit_by_node_comments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'node' in local_var_params:
            path_params['node'] = local_var_params['node']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/commit/{node}/comments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedCommitComments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_commit_by_node_comments_by_comment_id(self, username, node, comment_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_commit_by_node_comments_by_comment_id  # noqa: E501

        Returns the specified commit comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_commit_by_node_comments_by_comment_id(username, node, comment_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str node: The commit's SHA1. (required)
        :param int comment_id: The id of the comment. (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CommitComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_commit_by_node_comments_by_comment_id_with_http_info(username, node, comment_id, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_commit_by_node_comments_by_comment_id_with_http_info(self, username, node, comment_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_commit_by_node_comments_by_comment_id  # noqa: E501

        Returns the specified commit comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_commit_by_node_comments_by_comment_id_with_http_info(username, node, comment_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str node: The commit's SHA1. (required)
        :param int comment_id: The id of the comment. (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CommitComment, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'node', 'comment_id', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_commit_by_node_comments_by_comment_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_commit_by_node_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in local_var_params or
                local_var_params['node'] is None):
            raise ApiValueError("Missing the required parameter `node` when calling `get_repositories_by_username_by_repo_slug_commit_by_node_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'comment_id' is set
        if ('comment_id' not in local_var_params or
                local_var_params['comment_id'] is None):
            raise ApiValueError("Missing the required parameter `comment_id` when calling `get_repositories_by_username_by_repo_slug_commit_by_node_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_commit_by_node_comments_by_comment_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'node' in local_var_params:
            path_params['node'] = local_var_params['node']  # noqa: E501
        if 'comment_id' in local_var_params:
            path_params['comment_id'] = local_var_params['comment_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/commit/{node}/comments/{comment_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommitComment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_commits(self, username, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_commits  # noqa: E501

        These are the repository's commits. They are paginated and returned in reverse chronological order, similar to the output of `git log` and `hg log`. Like these tools, the DAG can be filtered.  ## GET /repositories/{username}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to `git log --all` and `hg log`).  ## GET /repositories/{username}/{repo_slug}/commits/master  Returns all commits on rev `master` (similar to `git log master`, `hg log master`).  ## GET /repositories/{username}/{repo_slug}/commits/dev?exclude=master  Returns all commits on ref `dev`, except those that are reachable on `master` (similar to `git log dev ^master`).  ## GET /repositories/{username}/{repo_slug}/commits/?exclude=master  Returns all commits in the repo that are not on master (similar to `git log --all ^master`).  ## GET /repositories/{username}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar  Returns all commits that are on refs `foo` or `bar`, but not on `fu` or `fubar` (similar to `git log foo bar ^fu ^fubar`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  ## GET /repositories/{username}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed the file README.md.  ## GET /repositories/{username}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the 'next' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_commits(username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_commits_with_http_info(username, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_commits_with_http_info(self, username, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_commits  # noqa: E501

        These are the repository's commits. They are paginated and returned in reverse chronological order, similar to the output of `git log` and `hg log`. Like these tools, the DAG can be filtered.  ## GET /repositories/{username}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to `git log --all` and `hg log`).  ## GET /repositories/{username}/{repo_slug}/commits/master  Returns all commits on rev `master` (similar to `git log master`, `hg log master`).  ## GET /repositories/{username}/{repo_slug}/commits/dev?exclude=master  Returns all commits on ref `dev`, except those that are reachable on `master` (similar to `git log dev ^master`).  ## GET /repositories/{username}/{repo_slug}/commits/?exclude=master  Returns all commits in the repo that are not on master (similar to `git log --all ^master`).  ## GET /repositories/{username}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar  Returns all commits that are on refs `foo` or `bar`, but not on `fu` or `fubar` (similar to `git log foo bar ^fu ^fubar`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  ## GET /repositories/{username}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed the file README.md.  ## GET /repositories/{username}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the 'next' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_commits_with_http_info(username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Error, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_commits" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_commits`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_commits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/commits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_commits_by_revision(self, username, revision, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_commits_by_revision  # noqa: E501

        These are the repository's commits. They are paginated and returned in reverse chronological order, similar to the output of `git log` and `hg log`. Like these tools, the DAG can be filtered.  ## GET /repositories/{username}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to `git log --all` and `hg log`).  ## GET /repositories/{username}/{repo_slug}/commits/master  Returns all commits on rev `master` (similar to `git log master`, `hg log master`).  ## GET /repositories/{username}/{repo_slug}/commits/dev?exclude=master  Returns all commits on ref `dev`, except those that are reachable on `master` (similar to `git log dev ^master`).  ## GET /repositories/{username}/{repo_slug}/commits/?exclude=master  Returns all commits in the repo that are not on master (similar to `git log --all ^master`).  ## GET /repositories/{username}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar  Returns all commits that are on refs `foo` or `bar`, but not on `fu` or `fubar` (similar to `git log foo bar ^fu ^fubar`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  ## GET /repositories/{username}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed the file README.md.  ## GET /repositories/{username}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the 'next' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_commits_by_revision(username, revision, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str revision: (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_commits_by_revision_with_http_info(username, revision, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_commits_by_revision_with_http_info(self, username, revision, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_commits_by_revision  # noqa: E501

        These are the repository's commits. They are paginated and returned in reverse chronological order, similar to the output of `git log` and `hg log`. Like these tools, the DAG can be filtered.  ## GET /repositories/{username}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to `git log --all` and `hg log`).  ## GET /repositories/{username}/{repo_slug}/commits/master  Returns all commits on rev `master` (similar to `git log master`, `hg log master`).  ## GET /repositories/{username}/{repo_slug}/commits/dev?exclude=master  Returns all commits on ref `dev`, except those that are reachable on `master` (similar to `git log dev ^master`).  ## GET /repositories/{username}/{repo_slug}/commits/?exclude=master  Returns all commits in the repo that are not on master (similar to `git log --all ^master`).  ## GET /repositories/{username}/{repo_slug}/commits/?include=foo&include=bar&exclude=fu&exclude=fubar  Returns all commits that are on refs `foo` or `bar`, but not on `fu` or `fubar` (similar to `git log foo bar ^fu ^fubar`).  An optional `path` parameter can be specified that will limit the results to commits that affect that path. `path` can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by `path`. It is important to note that if the `path` parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  ## GET /repositories/{username}/{repo_slug}/commits/?path=README.md&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed the file README.md.  ## GET /repositories/{username}/{repo_slug}/commits/?path=src/&include=foo&include=bar&exclude=master  Returns all commits that are on refs `foo` or `bar`, but not on `master` that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the 'next' link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a `x-www-form-urlencoded` POST instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_commits_by_revision_with_http_info(username, revision, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str revision: (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Error, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'revision', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_commits_by_revision" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_commits_by_revision`")  # noqa: E501
        # verify the required parameter 'revision' is set
        if ('revision' not in local_var_params or
                local_var_params['revision'] is None):
            raise ApiValueError("Missing the required parameter `revision` when calling `get_repositories_by_username_by_repo_slug_commits_by_revision`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_commits_by_revision`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'revision' in local_var_params:
            path_params['revision'] = local_var_params['revision']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/commits/{revision}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_diff_by_spec(self, username, spec, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_diff_by_spec  # noqa: E501

        Produces a raw, git-style diff for either a single commit (diffed against its first parent), or a revspec of 2 commits (e.g. `3a8b42..9ff173` where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a 3-way diff, or merge diff, is computed. This shows the changes introduced by the left branch (`3a8b42` in our example) as compared againt the right branch (`9ff173`).  This is equivalent to merging the left branch into the right branch and then computing the diff of the merge commit against its first parent (the right branch). This follows the same behavior as pull requests that also show this style of 3-way, or merge diff.  While similar to patches, diffs:  * Don't have a commit header (username, commit message, etc) * Support the optional `path=foo/bar.py` query param to filter   the diff to just that one file diff  The raw diff is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_diff_by_spec(username, spec, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str spec: (required)
        :param str repo_slug: (required)
        :param int context: Generate diffs with <n> lines of context instead of the usual three
        :param str path: Limit the diff to a particular file (this parameter can be repeated for multiple paths)
        :param bool ignore_whitespace: Generate diffs that ignore whitespace
        :param bool binary: Generate diffs that include binary files,true if omitted.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_diff_by_spec_with_http_info(username, spec, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_diff_by_spec_with_http_info(self, username, spec, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_diff_by_spec  # noqa: E501

        Produces a raw, git-style diff for either a single commit (diffed against its first parent), or a revspec of 2 commits (e.g. `3a8b42..9ff173` where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a 3-way diff, or merge diff, is computed. This shows the changes introduced by the left branch (`3a8b42` in our example) as compared againt the right branch (`9ff173`).  This is equivalent to merging the left branch into the right branch and then computing the diff of the merge commit against its first parent (the right branch). This follows the same behavior as pull requests that also show this style of 3-way, or merge diff.  While similar to patches, diffs:  * Don't have a commit header (username, commit message, etc) * Support the optional `path=foo/bar.py` query param to filter   the diff to just that one file diff  The raw diff is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_diff_by_spec_with_http_info(username, spec, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str spec: (required)
        :param str repo_slug: (required)
        :param int context: Generate diffs with <n> lines of context instead of the usual three
        :param str path: Limit the diff to a particular file (this parameter can be repeated for multiple paths)
        :param bool ignore_whitespace: Generate diffs that ignore whitespace
        :param bool binary: Generate diffs that include binary files,true if omitted.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'spec', 'repo_slug', 'context', 'path', 'ignore_whitespace', 'binary']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_diff_by_spec" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_diff_by_spec`")  # noqa: E501
        # verify the required parameter 'spec' is set
        if ('spec' not in local_var_params or
                local_var_params['spec'] is None):
            raise ApiValueError("Missing the required parameter `spec` when calling `get_repositories_by_username_by_repo_slug_diff_by_spec`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_diff_by_spec`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'spec' in local_var_params:
            path_params['spec'] = local_var_params['spec']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []
        if 'context' in local_var_params:
            query_params.append(('context', local_var_params['context']))  # noqa: E501
        if 'path' in local_var_params:
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if 'ignore_whitespace' in local_var_params:
            query_params.append(('ignore_whitespace', local_var_params['ignore_whitespace']))  # noqa: E501
        if 'binary' in local_var_params:
            query_params.append(('binary', local_var_params['binary']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/diff/{spec}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_patch_by_spec(self, username, spec, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_patch_by_spec  # noqa: E501

        Produces a raw patch for a single commit (diffed against its first parent), or a patch-series for a revspec of 2 commits (e.g. `3a8b42..9ff173` where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a patch series is returned for the commits on the source branch (`3a8b42` and its ancestors in our example). For Mercurial, a single patch is returned that combines the changes of all commits on the source branch.  While similar to diffs, patches:  * Have a commit header (username, commit message, etc) * Do not support the `path=foo/bar.py` query parameter  The raw patch is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_patch_by_spec(username, spec, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str spec: (required)
        :param str repo_slug: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_patch_by_spec_with_http_info(username, spec, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_patch_by_spec_with_http_info(self, username, spec, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_patch_by_spec  # noqa: E501

        Produces a raw patch for a single commit (diffed against its first parent), or a patch-series for a revspec of 2 commits (e.g. `3a8b42..9ff173` where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a patch series is returned for the commits on the source branch (`3a8b42` and its ancestors in our example). For Mercurial, a single patch is returned that combines the changes of all commits on the source branch.  While similar to diffs, patches:  * Have a commit header (username, commit message, etc) * Do not support the `path=foo/bar.py` query parameter  The raw patch is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is `text/plain`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_patch_by_spec_with_http_info(username, spec, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str spec: (required)
        :param str repo_slug: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'spec', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_patch_by_spec" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_patch_by_spec`")  # noqa: E501
        # verify the required parameter 'spec' is set
        if ('spec' not in local_var_params or
                local_var_params['spec'] is None):
            raise ApiValueError("Missing the required parameter `spec` when calling `get_repositories_by_username_by_repo_slug_patch_by_spec`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_patch_by_spec`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'spec' in local_var_params:
            path_params['spec'] = local_var_params['spec']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/patch/{spec}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
