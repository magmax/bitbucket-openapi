# coding: utf-8

"""
    Bitbucket API

    Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.  # noqa: E501

    The version of the OpenAPI document: 2.0
    Contact: support@bitbucket.org
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from bitbucketopenapi.api_client import ApiClient
from bitbucketopenapi.exceptions import (
    ApiTypeError,
    ApiValueError
)


class PullrequestsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_repositories_by_username_by_repo_slug_pullrequests(self, username, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_pullrequests  # noqa: E501

        Creates a new pull request where the destination repository is this repository and the author is the authenticated user.  The minimum required fields to create a pull request are `title` and `source`, specified by a branch name.  ``` curl https://api.bitbucket.org/2.0/repositories/my-username/my-repository/pullrequests \\     -u my-username:my-password \\     --request POST \\     --header 'Content-Type: application/json' \\     --data '{         \"title\": \"My Title\",         \"source\": {             \"branch\": {                 \"name\": \"staging\"             }         }     }' ```  If the pull request's `destination` is not specified, it will default to the `repository.mainbranch`. To open a pull request to a different branch, say from a feature branch to a staging branch, specify a `destination` (same format as the `source`):  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"destination\": {         \"branch\": {             \"name\": \"staging\"         }     } } ```  Reviewers can be specified by adding an array of user objects as the `reviewers` property.  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"reviewers\": [         {             \"uuid\": \"{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\"         }     ] } ```  Other fields:  * `description` - a string * `close_source_branch` - boolean that specifies if the source branch should be closed upon merging  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_pullrequests(username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param Pullrequest body: The new pull request.  The request URL you POST to becomes the destination repository URL. For this reason, you must specify an explicit source repository in the request object if you want to pull from a different repository (fork).  Since not all elements are required or even mutable, you only need to include the elements you want to initialize, such as the source branch and the title.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Pullrequest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_repositories_by_username_by_repo_slug_pullrequests_with_http_info(username, repo_slug, **kwargs)  # noqa: E501

    def create_repositories_by_username_by_repo_slug_pullrequests_with_http_info(self, username, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_pullrequests  # noqa: E501

        Creates a new pull request where the destination repository is this repository and the author is the authenticated user.  The minimum required fields to create a pull request are `title` and `source`, specified by a branch name.  ``` curl https://api.bitbucket.org/2.0/repositories/my-username/my-repository/pullrequests \\     -u my-username:my-password \\     --request POST \\     --header 'Content-Type: application/json' \\     --data '{         \"title\": \"My Title\",         \"source\": {             \"branch\": {                 \"name\": \"staging\"             }         }     }' ```  If the pull request's `destination` is not specified, it will default to the `repository.mainbranch`. To open a pull request to a different branch, say from a feature branch to a staging branch, specify a `destination` (same format as the `source`):  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"destination\": {         \"branch\": {             \"name\": \"staging\"         }     } } ```  Reviewers can be specified by adding an array of user objects as the `reviewers` property.  ``` {     \"title\": \"My Title\",     \"source\": {         \"branch\": {             \"name\": \"my-feature-branch\"         }     },     \"reviewers\": [         {             \"uuid\": \"{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\"         }     ] } ```  Other fields:  * `description` - a string * `close_source_branch` - boolean that specifies if the source branch should be closed upon merging  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_pullrequests_with_http_info(username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param Pullrequest body: The new pull request.  The request URL you POST to becomes the destination repository URL. For this reason, you must specify an explicit source repository in the request object if you want to pull from a different repository (fork).  Since not all elements are required or even mutable, you only need to include the elements you want to initialize, such as the source branch and the title.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Pullrequest, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'repo_slug', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repositories_by_username_by_repo_slug_pullrequests" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `create_repositories_by_username_by_repo_slug_pullrequests`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `create_repositories_by_username_by_repo_slug_pullrequests`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Pullrequest',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve  # noqa: E501

        Approve the specified pull request as the authenticated user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Participant
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve_with_http_info(username, pull_request_id, repo_slug, **kwargs)  # noqa: E501

    def create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve_with_http_info(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve  # noqa: E501

        Approve the specified pull request as the authenticated user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve_with_http_info(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Participant, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'pull_request_id', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/approve', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Participant',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments(self, username, repo_slug, pull_request_id, body, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments  # noqa: E501

        Creates a new pull request comment.  Returns the newly created pull request comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments(username, repo_slug, pull_request_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param PullrequestComment body: The comment object. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PullrequestComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_with_http_info(username, repo_slug, pull_request_id, body, **kwargs)  # noqa: E501

    def create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_with_http_info(self, username, repo_slug, pull_request_id, body, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments  # noqa: E501

        Creates a new pull request comment.  Returns the newly created pull request comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_with_http_info(username, repo_slug, pull_request_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param PullrequestComment body: The comment object. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PullrequestComment, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'repo_slug', 'pull_request_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/comments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PullrequestComment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_decline(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_decline  # noqa: E501

        Declines the pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_decline(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Pullrequest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_decline_with_http_info(username, pull_request_id, repo_slug, **kwargs)  # noqa: E501

    def create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_decline_with_http_info(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_decline  # noqa: E501

        Declines the pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_decline_with_http_info(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Pullrequest, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'pull_request_id', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_decline" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_decline`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_decline`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_decline`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/decline', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Pullrequest',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_merge(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_merge  # noqa: E501

        Merges the pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_merge(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param PullrequestMergeParameters body:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Pullrequest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_merge_with_http_info(username, pull_request_id, repo_slug, **kwargs)  # noqa: E501

    def create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_merge_with_http_info(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_merge  # noqa: E501

        Merges the pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_merge_with_http_info(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param PullrequestMergeParameters body:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Pullrequest, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'pull_request_id', 'repo_slug', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_merge" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_merge`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_merge`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `create_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_merge`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/merge', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Pullrequest',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username(self, username, target_username, repo_slug, **kwargs):  # noqa: E501
        """delete_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username  # noqa: E501

        Removes a default reviewer from the repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username(username, target_username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str target_username: This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username_with_http_info(username, target_username, repo_slug, **kwargs)  # noqa: E501

    def delete_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username_with_http_info(self, username, target_username, repo_slug, **kwargs):  # noqa: E501
        """delete_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username  # noqa: E501

        Removes a default reviewer from the repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username_with_http_info(username, target_username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str target_username: This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Error, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'target_username', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `delete_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username`")  # noqa: E501
        # verify the required parameter 'target_username' is set
        if ('target_username' not in local_var_params or
                local_var_params['target_username'] is None):
            raise ApiValueError("Missing the required parameter `target_username` when calling `delete_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `delete_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'target_username' in local_var_params:
            path_params['target_username'] = local_var_params['target_username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/default-reviewers/{target_username}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve  # noqa: E501

        Redact the authenticated user's approval of the specified pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve_with_http_info(username, pull_request_id, repo_slug, **kwargs)  # noqa: E501

    def delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve_with_http_info(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve  # noqa: E501

        Redact the authenticated user's approval of the specified pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve_with_http_info(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'pull_request_id', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_approve`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/approve', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id(self, username, pull_request_id, comment_id, repo_slug, **kwargs):  # noqa: E501
        """delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id  # noqa: E501

        Deletes a specific pull request comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id(username, pull_request_id, comment_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str comment_id: (required)
        :param str repo_slug: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id_with_http_info(username, pull_request_id, comment_id, repo_slug, **kwargs)  # noqa: E501

    def delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id_with_http_info(self, username, pull_request_id, comment_id, repo_slug, **kwargs):  # noqa: E501
        """delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id  # noqa: E501

        Deletes a specific pull request comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id_with_http_info(username, pull_request_id, comment_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str comment_id: (required)
        :param str repo_slug: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'pull_request_id', 'comment_id', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'comment_id' is set
        if ('comment_id' not in local_var_params or
                local_var_params['comment_id'] is None):
            raise ApiValueError("Missing the required parameter `comment_id` when calling `delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `delete_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501
        if 'comment_id' in local_var_params:
            path_params['comment_id'] = local_var_params['comment_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pullrequests_by_target_user(self, target_user, username, **kwargs):  # noqa: E501
        """get_pullrequests_by_target_user  # noqa: E501

        Returns all pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../meta/filtering) for more details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pullrequests_by_target_user(target_user, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str target_user: (required)
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str state: Only return pull requests that are in this state. This parameter can be repeated.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedPullrequests
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_pullrequests_by_target_user_with_http_info(target_user, username, **kwargs)  # noqa: E501

    def get_pullrequests_by_target_user_with_http_info(self, target_user, username, **kwargs):  # noqa: E501
        """get_pullrequests_by_target_user  # noqa: E501

        Returns all pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../meta/filtering) for more details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pullrequests_by_target_user_with_http_info(target_user, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str target_user: (required)
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str state: Only return pull requests that are in this state. This parameter can be repeated.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedPullrequests, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['target_user', 'username', 'state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pullrequests_by_target_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'target_user' is set
        if ('target_user' not in local_var_params or
                local_var_params['target_user'] is None):
            raise ApiValueError("Missing the required parameter `target_user` when calling `get_pullrequests_by_target_user`")  # noqa: E501
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_pullrequests_by_target_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_user' in local_var_params:
            path_params['target_user'] = local_var_params['target_user']  # noqa: E501
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501

        query_params = []
        if 'state' in local_var_params:
            query_params.append(('state', local_var_params['state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/pullrequests/{target_user}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedPullrequests',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pullrequests_for_commit(self, username, repo_slug, commit, **kwargs):  # noqa: E501
        """Returns a paginated list of all pull requests as part of which this commit was reviewed.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pullrequests_for_commit(username, repo_slug, commit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The account; either the UUID in curly braces, or the account_id (required)
        :param str repo_slug: The repository; either the UUID in curly braces, or the slug (required)
        :param str commit: The SHA1 of the commit (required)
        :param int page: Which page to retrieve
        :param int pagelen: How many pull requests to retrieve per page
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedPullrequests
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_pullrequests_for_commit_with_http_info(username, repo_slug, commit, **kwargs)  # noqa: E501

    def get_pullrequests_for_commit_with_http_info(self, username, repo_slug, commit, **kwargs):  # noqa: E501
        """Returns a paginated list of all pull requests as part of which this commit was reviewed.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pullrequests_for_commit_with_http_info(username, repo_slug, commit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The account; either the UUID in curly braces, or the account_id (required)
        :param str repo_slug: The repository; either the UUID in curly braces, or the slug (required)
        :param str commit: The SHA1 of the commit (required)
        :param int page: Which page to retrieve
        :param int pagelen: How many pull requests to retrieve per page
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedPullrequests, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'repo_slug', 'commit', 'page', 'pagelen']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pullrequests_for_commit" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_pullrequests_for_commit`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_pullrequests_for_commit`")  # noqa: E501
        # verify the required parameter 'commit' is set
        if ('commit' not in local_var_params or
                local_var_params['commit'] is None):
            raise ApiValueError("Missing the required parameter `commit` when calling `get_pullrequests_for_commit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501
        if 'commit' in local_var_params:
            path_params['commit'] = local_var_params['commit']  # noqa: E501

        query_params = []
        if 'page' in local_var_params:
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'pagelen' in local_var_params:
            query_params.append(('pagelen', local_var_params['pagelen']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{workspace}/{repo_slug}/commit/{commit}/pullrequests', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedPullrequests',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_defaultreviewers(self, username, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_defaultreviewers  # noqa: E501

        Returns the repository's default reviewers.  These are the users that are automatically added as reviewers on every new pull request that is created.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_defaultreviewers(username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_defaultreviewers_with_http_info(username, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_defaultreviewers_with_http_info(self, username, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_defaultreviewers  # noqa: E501

        Returns the repository's default reviewers.  These are the users that are automatically added as reviewers on every new pull request that is created.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_defaultreviewers_with_http_info(username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_defaultreviewers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_defaultreviewers`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_defaultreviewers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/default-reviewers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username(self, username, target_username, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username  # noqa: E501

        Returns the specified reviewer.  This can be used to test whether a user is among the repository's default reviewers list. A 404 indicates that that specified user is not a default reviewer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username(username, target_username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str target_username: This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username_with_http_info(username, target_username, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username_with_http_info(self, username, target_username, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username  # noqa: E501

        Returns the specified reviewer.  This can be used to test whether a user is among the repository's default reviewers list. A 404 indicates that that specified user is not a default reviewer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username_with_http_info(username, target_username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str target_username: This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Error, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'target_username', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username`")  # noqa: E501
        # verify the required parameter 'target_username' is set
        if ('target_username' not in local_var_params or
                local_var_params['target_username'] is None):
            raise ApiValueError("Missing the required parameter `target_username` when calling `get_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'target_username' in local_var_params:
            path_params['target_username'] = local_var_params['target_username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/default-reviewers/{target_username}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_pullrequests(self, username, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests  # noqa: E501

        Returns all pull requests on the specified repository.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../meta/filtering) for more details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests(username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param str state: Only return pull requests that are in this state. This parameter can be repeated.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedPullrequests
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_pullrequests_with_http_info(username, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_pullrequests_with_http_info(self, username, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests  # noqa: E501

        Returns all pull requests on the specified repository.  By default only open pull requests are returned. This can be controlled using the `state` query parameter. To retrieve pull requests that are in one of multiple states, repeat the `state` parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../meta/filtering) for more details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_with_http_info(username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param str state: Only return pull requests that are in this state. This parameter can be repeated.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedPullrequests, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'repo_slug', 'state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_pullrequests" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_pullrequests`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_pullrequests`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []
        if 'state' in local_var_params:
            query_params.append(('state', local_var_params['state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedPullrequests',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_pullrequests_activity(self, username, repo_slug, pull_request_id, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_activity  # noqa: E501

        Returns a paginated list of the pull request's activity log.  This includes comments that were made by the reviewers, updates and approvals.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_activity(username, repo_slug, pull_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_pullrequests_activity_with_http_info(username, repo_slug, pull_request_id, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_pullrequests_activity_with_http_info(self, username, repo_slug, pull_request_id, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_activity  # noqa: E501

        Returns a paginated list of the pull request's activity log.  This includes comments that were made by the reviewers, updates and approvals.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_activity_with_http_info(username, repo_slug, pull_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'repo_slug', 'pull_request_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_pullrequests_activity" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_pullrequests_activity`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_pullrequests_activity`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `get_repositories_by_username_by_repo_slug_pullrequests_activity`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/activity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id(self, username, repo_slug, pull_request_id, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id  # noqa: E501

        Returns the specified pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id(username, repo_slug, pull_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Pullrequest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_with_http_info(username, repo_slug, pull_request_id, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_with_http_info(self, username, repo_slug, pull_request_id, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id  # noqa: E501

        Returns the specified pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_with_http_info(username, repo_slug, pull_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Pullrequest, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'repo_slug', 'pull_request_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Pullrequest',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_activity(self, username, repo_slug, pull_request_id, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_activity  # noqa: E501

        Returns a paginated list of the pull request's activity log.  This includes comments that were made by the reviewers, updates and approvals.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_activity(username, repo_slug, pull_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_activity_with_http_info(username, repo_slug, pull_request_id, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_activity_with_http_info(self, username, repo_slug, pull_request_id, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_activity  # noqa: E501

        Returns a paginated list of the pull request's activity log.  This includes comments that were made by the reviewers, updates and approvals.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_activity_with_http_info(username, repo_slug, pull_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'repo_slug', 'pull_request_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_activity" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_activity`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_activity`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_activity`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/activity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments(self, username, repo_slug, pull_request_id, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments  # noqa: E501

        Returns a paginated list of the pull request's comments.  This includes both global, inline comments and replies.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../../../meta/filtering) for more details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments(username, repo_slug, pull_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedPullrequestComments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_with_http_info(username, repo_slug, pull_request_id, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_with_http_info(self, username, repo_slug, pull_request_id, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments  # noqa: E501

        Returns a paginated list of the pull request's comments.  This includes both global, inline comments and replies.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../../../meta/filtering) for more details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_with_http_info(username, repo_slug, pull_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedPullrequestComments, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'repo_slug', 'pull_request_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/comments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedPullrequestComments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id(self, username, pull_request_id, comment_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id  # noqa: E501

        Returns a specific pull request comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id(username, pull_request_id, comment_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str comment_id: (required)
        :param str repo_slug: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PullrequestComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id_with_http_info(username, pull_request_id, comment_id, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id_with_http_info(self, username, pull_request_id, comment_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id  # noqa: E501

        Returns a specific pull request comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id_with_http_info(username, pull_request_id, comment_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str comment_id: (required)
        :param str repo_slug: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PullrequestComment, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'pull_request_id', 'comment_id', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'comment_id' is set
        if ('comment_id' not in local_var_params or
                local_var_params['comment_id'] is None):
            raise ApiValueError("Missing the required parameter `comment_id` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501
        if 'comment_id' in local_var_params:
            path_params['comment_id'] = local_var_params['comment_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PullrequestComment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_commits(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_commits  # noqa: E501

        Returns a paginated list of the pull request's commits.  These are the commits that are being merged into the destination branch when the pull requests gets accepted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_commits(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_commits_with_http_info(username, pull_request_id, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_commits_with_http_info(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_commits  # noqa: E501

        Returns a paginated list of the pull request's commits.  These are the commits that are being merged into the destination branch when the pull requests gets accepted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_commits_with_http_info(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Error, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'pull_request_id', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_commits" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_commits`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_commits`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_commits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/commits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diff(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diff  # noqa: E501

        Redirects to the [repository diff](../../diff/%7Bspec%7D) with the revspec that corresponds to the pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diff(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diff_with_http_info(username, pull_request_id, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diff_with_http_info(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diff  # noqa: E501

        Redirects to the [repository diff](../../diff/%7Bspec%7D) with the revspec that corresponds to the pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diff_with_http_info(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'pull_request_id', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diff" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diff`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diff`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diff`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/diff', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diffstat(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diffstat  # noqa: E501

        Redirects to the [repository diffstat](../../diffstat/%7Bspec%7D) with the revspec that corresponds to the pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diffstat(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diffstat_with_http_info(username, pull_request_id, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diffstat_with_http_info(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diffstat  # noqa: E501

        Redirects to the [repository diffstat](../../diffstat/%7Bspec%7D) with the revspec that corresponds to the pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diffstat_with_http_info(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'pull_request_id', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diffstat" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diffstat`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diffstat`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_diffstat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/diffstat', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_patch(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_patch(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_patch_with_http_info(username, pull_request_id, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_patch_with_http_info(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_patch_with_http_info(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str repo_slug: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Error, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'pull_request_id', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_patch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_patch`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_patch`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/patch', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_statuses(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_statuses  # noqa: E501

        Returns all statuses (e.g. build results) for the given pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_statuses(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedCommitstatuses
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_statuses_with_http_info(username, pull_request_id, repo_slug, **kwargs)  # noqa: E501

    def get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_statuses_with_http_info(self, username, pull_request_id, repo_slug, **kwargs):  # noqa: E501
        """get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_statuses  # noqa: E501

        Returns all statuses (e.g. build results) for the given pull request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_statuses_with_http_info(username, pull_request_id, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedCommitstatuses, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'pull_request_id', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_statuses" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_statuses`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_statuses`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `get_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_statuses`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/statuses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedCommitstatuses',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username(self, username, target_username, repo_slug, **kwargs):  # noqa: E501
        """update_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username  # noqa: E501

        Adds the specified user to the repository's list of default reviewers.  This method is idempotent. Adding a user a second time has no effect.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username(username, target_username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str target_username: This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Error
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username_with_http_info(username, target_username, repo_slug, **kwargs)  # noqa: E501

    def update_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username_with_http_info(self, username, target_username, repo_slug, **kwargs):  # noqa: E501
        """update_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username  # noqa: E501

        Adds the specified user to the repository's list of default reviewers.  This method is idempotent. Adding a user a second time has no effect.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username_with_http_info(username, target_username, repo_slug, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str target_username: This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Error, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'target_username', 'repo_slug']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `update_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username`")  # noqa: E501
        # verify the required parameter 'target_username' is set
        if ('target_username' not in local_var_params or
                local_var_params['target_username'] is None):
            raise ApiValueError("Missing the required parameter `target_username` when calling `update_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `update_repositories_by_username_by_repo_slug_defaultreviewers_by_target_username`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'target_username' in local_var_params:
            path_params['target_username'] = local_var_params['target_username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/default-reviewers/{target_username}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Error',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id(self, username, repo_slug, pull_request_id, **kwargs):  # noqa: E501
        """update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id  # noqa: E501

        Mutates the specified pull request.  This can be used to change the pull request's branches or description.  Only open pull requests can be mutated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id(username, repo_slug, pull_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param Pullrequest body: The pull request that is to be updated.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Pullrequest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_with_http_info(username, repo_slug, pull_request_id, **kwargs)  # noqa: E501

    def update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_with_http_info(self, username, repo_slug, pull_request_id, **kwargs):  # noqa: E501
        """update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id  # noqa: E501

        Mutates the specified pull request.  This can be used to change the pull request's branches or description.  Only open pull requests can be mutated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_with_http_info(username, repo_slug, pull_request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.  (required)
        :param str repo_slug: This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.  (required)
        :param int pull_request_id: The id of the pull request. (required)
        :param Pullrequest body: The pull request that is to be updated.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Pullrequest, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'repo_slug', 'pull_request_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Pullrequest',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id(self, username, pull_request_id, comment_id, repo_slug, body, **kwargs):  # noqa: E501
        """update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id  # noqa: E501

        Updates a specific pull request comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id(username, pull_request_id, comment_id, repo_slug, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str comment_id: (required)
        :param str repo_slug: (required)
        :param PullrequestComment body: The contents of the updated comment. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PullrequestComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id_with_http_info(username, pull_request_id, comment_id, repo_slug, body, **kwargs)  # noqa: E501

    def update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id_with_http_info(self, username, pull_request_id, comment_id, repo_slug, body, **kwargs):  # noqa: E501
        """update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id  # noqa: E501

        Updates a specific pull request comment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id_with_http_info(username, pull_request_id, comment_id, repo_slug, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: (required)
        :param str pull_request_id: (required)
        :param str comment_id: (required)
        :param str repo_slug: (required)
        :param PullrequestComment body: The contents of the updated comment. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PullrequestComment, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['username', 'pull_request_id', 'comment_id', 'repo_slug', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in local_var_params or
                local_var_params['username'] is None):
            raise ApiValueError("Missing the required parameter `username` when calling `update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'pull_request_id' is set
        if ('pull_request_id' not in local_var_params or
                local_var_params['pull_request_id'] is None):
            raise ApiValueError("Missing the required parameter `pull_request_id` when calling `update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'comment_id' is set
        if ('comment_id' not in local_var_params or
                local_var_params['comment_id'] is None):
            raise ApiValueError("Missing the required parameter `comment_id` when calling `update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'repo_slug' is set
        if ('repo_slug' not in local_var_params or
                local_var_params['repo_slug'] is None):
            raise ApiValueError("Missing the required parameter `repo_slug` when calling `update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `update_repositories_by_username_by_repo_slug_pullrequests_by_pull_request_id_comments_by_comment_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'pull_request_id' in local_var_params:
            path_params['pull_request_id'] = local_var_params['pull_request_id']  # noqa: E501
        if 'comment_id' in local_var_params:
            path_params['comment_id'] = local_var_params['comment_id']  # noqa: E501
        if 'repo_slug' in local_var_params:
            path_params['repo_slug'] = local_var_params['repo_slug']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'basic', 'oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PullrequestComment',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
